# import dependencies
from __future__ import annotations

from typing import Optional, TYPE_CHECKING
import tcod.event
from actions import Action, EscapeAction, BumpAction, WaitAction  # type: ignore

if TYPE_CHECKING:
    from engine import Engine

#
MOVE_KEYS = {
    # arrow keys
    tcod.event.KeySym.UP: ( 0, -1 ),
    tcod.event.KeySym.DOWN: ( 0, 1 ),
    tcod.event.KeySym.LEFT: ( -1, 0 ),
    tcod.event.KeySym.RIGHT: ( 1, 0 ),
    tcod.event.KeySym.HOME: ( -1, 1 ),
    tcod.event.KeySym.END: ( 1, 1 ),
    tcod.event.KeySym.PAGEUP: ( -1, -1 ),
    tcod.event.KeySym.PAGEDOWN: ( 1, -1 ),
    # numpad keys
    tcod.event.KeySym.KP_1: ( -1, 1 ),
    tcod.event.KeySym.KP_2: ( 0, 1 ),
    tcod.event.KeySym.KP_3: ( 1, 1 ),
    tcod.event.KeySym.KP_4: ( -1, 0 ),
    tcod.event.KeySym.KP_6: ( 1, 0 ),
    tcod.event.KeySym.KP_7: ( -1, -1 ),
    tcod.event.KeySym.KP_8: ( 0, -1 ),
    tcod.event.KeySym.KP_9: ( 1, -1 )
}

#
WAIT_KEYS = {
    tcod.event.KeySym.KP_PERIOD,
    tcod.event.KeySym.KP_5,
    tcod.event.KeySym.KP_CLEAR
}

# used to dispatch events to specific methods
class EventHandler( tcod.event.EventDispatch[ Action ] ):

    def __init__( self, engine: Engine ):

        self.engine = engine

    def handle_events( self, context: tcod.context.Context ) -> None:

        for event in tcod.event.wait():

            context.convert_event( event )

            self.dispatch( event )

    def ev_mousemotion( self, event: tcod.event.MouseMotion ) -> None:

        if self.engine.game_map.in_bounds( event.tile.x, event.tile.y ):

            self.engine.mouse_location = event.tile.x, event.tile.y
    
    def ev_quit( self, event: tcod.event.quit ) -> Optional[ Action ]:

        raise SystemExit()
    
    def on_render( self, console: tcod.Console ) -> None:

        self.engine.render( console )

#
class MainGameEventHandler( EventHandler ):

    # handle events generated by the user
    def handle_events( self, context: tcod.context.Context ) -> None:

        # event queue
        for event in tcod.event.wait():

            context.convert_event( event )

            # initialize the action with the event generated by the user
            action = self.dispatch( event )

            if action is None:

                continue

            # execute the action
            action.perform()

            # handle enemy turns
            self.engine.handle_enemy_turns()

            # update the fov before the player's next action
            self.engine.update_fov()
    
    # return the appropriate Action object based on event input
    def ev_keydown( self, event: tcod.event.KeyDown ) -> Optional[ Action ]:

        # initialize Action object
        action: Optional[ Action ] = None

        # capture key press
        key = event.sym

        # grab the player from the engine
        player = self.engine.player

        # user attempts to move
        if key in MOVE_KEYS:

            dx, dy = MOVE_KEYS[ key ]

            action = BumpAction( player, dx, dy )

        # user attempts to wait
        elif key in WAIT_KEYS:

            action = WaitAction( player )

        # user presses escape
        elif key == tcod.event.KeySym.ESCAPE:

            action = EscapeAction( player )

        # return Action object, or none if no relevant key press was detected
        return action
    
#
class GameOverEventHandler( EventHandler ):

    # handle events generated by the user
    def handle_events( self, context: tcod.context.Context ) -> None:

        # event queue
        for event in tcod.event.wait():

            context.convert_event( event )

            # initialize the action with the event generated by the user
            action = self.dispatch( event )

            if action is None:

                continue

            # execute the action
            action.perform()

    # return the appropriate Action object based on event input
    def ev_keydown( self, event: tcod.event.KeyDown ) -> Optional[ Action ]:

        # initialize Action object
        action: Optional[ Action ] = None

        # capture key press
        key = event.sym

        # user presses escape
        if key == tcod.event.KeySym.ESCAPE:

            action = EscapeAction( self.engine.player )

        # no valid keys was pressed
        return action